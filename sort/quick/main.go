package main

import "fmt"

func main() {
	s := []int{5, 2, 3, 5, 9, 1, -1, 0, -4, 2}
	fmt.Println("unsorted: ", s)
	quicksort(s)
	fmt.Println("result: ", s)

	s = []int{5, 2, 3, 5, 9, 1, -1, 0, -4, 2}
	quickSortIterative(s)
	fmt.Println("result: ", s)
}

/*
From wikipedia (Quicksort):
The recursive quicksort pseudo code

algorithm quicksort(A, lo, hi) is
    if lo < hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1 )
        quicksort(A, p + 1, hi)

In Go we can slice our slices (and our arrays)
So we don't have to pass into the function the upper and lower bound.
Instead we need to check the length of our slice and stop when
there's nothing to sort (length < 2)
To slice given slice a from 0 to l (not including l): a[:l]
To slice given slice a from l to the end of a: a[l:]
*/
func quicksort(unsorted []int) {
	hi := len(unsorted) - 1

	if hi > 2 {
		pivot := partition(unsorted)
		quicksort(unsorted[:pivot])
		quicksort(unsorted[pivot+1:])
	}
}

func swap(arr []int, i, j int) {
	temp := arr[i]
	arr[i] = arr[j]
	arr[j] = temp
}

func partition(arr []int) int {
	l := 0
	h := len(arr) - 1 // before last
	pivot := arr[h]   //last
	i := l - 1        // -1

	for j := l; j <= h-1; j++ {
		if arr[j] < pivot {
			i++
			swap(arr, i, j)
		}
	}
	swap(arr, i+1, h)
	return i + 1
}

type pair struct {
	left  int
	right int
}

func quickSortIterative(arr []int) {
	l := 0
	r := len(arr)

	var top int
	stack := make([]pair, len(arr))
	stack[top] = pair{left: l, right: r}

	for top >= 0 {
		l, r = stack[top].left, stack[top].right
		top--

		p := partition(arr[l:r])

		//p is the index of the pivot in the inner slice, add l to get
		//its index in the outer slice
		if p+l > l {
			top++
			stack[top] = pair{left: l, right: p + l}
		}

		if p+l+1 < r {
			top++
			stack[top] = pair{left: p + l + 1, right: r}
		}
	}
}
